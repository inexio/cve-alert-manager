package fetcher

import (
	alertmanager "cve-alert-manager"
	"encoding/xml"
	"fmt"
	"github.com/emersion/go-message"
	"github.com/jchavannes/go-pgp/pgp"
	"github.com/jmoiron/sqlx"
	"github.com/pkg/errors"
	"github.com/rs/zerolog/log"
	"github.com/spf13/viper"
	"github.com/taknb2nch/go-pop3"
	"io"
	"io/ioutil"
	"mime"
	"net/mail"
	"regexp"
	"strconv"
	"strings"
	"time"
)

var tables = []string{
	"case_categories",
	"case_comments",
	"case_cvenums",
	"case_descriptions",
	"case_platforms",
	"case_rawdatas",
	"case_softwares",
}

func decodeRFC2047(s string) string {
	// GO 1.5 does not decode headers, but this may change in future releases...
	decoded, err := (&mime.WordDecoder{}).DecodeHeader(s)
	if err != nil || len(decoded) == 0 {
		return s
	}
	return decoded
}

func newPop3Client(host, user, password string) (*pop3.Client, error) {
	client, err := pop3.Dial(host)
	if err != nil {
		err := errors.Wrap(err, "Failed to connect to POP3 Server")
		return nil, err
	}

	if err = client.User(user); err != nil {
		err := errors.Wrap(err, "Error during POP3-User Command")
		return nil, err
	}

	if err = client.Pass(password); err != nil {
		err := errors.Wrap(err, "Error during POP3-Pass Command")
		return nil, err
	}

	return client, nil
}

func closePop3Client(client *pop3.Client) error {
	err := client.Quit()
	if err != nil {
		log.Error().
			AnErr("Error", err).
			Msg("Error while quitting POP3 Client")
		return err
	}
	err = client.Close()
	if err != nil {
		err := errors.Wrap(err, "Error while closing POP3 Connection")
		return err
	}

	return nil
}

func getMessageInfo(client *pop3.Client) ([]pop3.MessageInfo, error) {
	var mis []pop3.MessageInfo
	mis, err := client.UidlAll()
	if err != nil {
		err := errors.Wrap(err, "Error while getting Mail UIDs")
		return nil, err
	}

	return mis, nil
}

func createCVECase(m *message.Entity) (alertmanager.CveCase, error) {
	c := alertmanager.CveCase{}
	c.Subject = decodeRFC2047(m.Header.Get("Subject"))
	mailDate := m.Header.Get("Date")
	mailDateTime, err := mail.ParseDate(mailDate)
	if err != nil {
		err := errors.Wrap(err, "Error while parsing Header Date")
		return alertmanager.CveCase{}, err
	}
	c.DateCreated = fmt.Sprintf("%d-%02d-%02d %02d:%02d:%02d",
		mailDateTime.Year(), mailDateTime.Month(), mailDateTime.Day(),
		mailDateTime.Hour(), mailDateTime.Minute(), mailDateTime.Second())
	c.MsgFrom = m.Header.Get("From")
	if c.MsgFrom != "wid@mail.cert-bund.de" {
		return alertmanager.CveCase{}, errors.New("email is not from Cert-Bund")
	}
	c.MsgTo = m.Header.Get("To")

	return c, nil
}

func getMultipartInfo(m *message.Entity, content string, cve *alertmanager.CveCase) (string, error) {
	var xmlData string
	mr := m.MultipartReader()
	if mr == nil {
		return "", errors.New("is not a multipart")
	}

	log.Debug().
		Msg("This is a multipart message")

	for {
		p, err := mr.NextPart()
		if err != nil {
			if err == io.EOF {
				break
			}
			err := errors.Wrap(err, "Error while getting next multipart")
			return "", err
		}
		partDataBytes, err := ioutil.ReadAll(p.Body)
		if err != nil {
			err := errors.Wrap(err, "Error while reading Body")
			return "", err
		}
		partData := string(partDataBytes)
		t, _, err := p.Header.ContentType()
		if err != nil {
			err := errors.Wrap(err, "Error while reading content type")
			return "", err
		}
		if t == "text/xml" {
			xmlData = partData
			//spew.Dump(xmlData)
			if xmlData == "" {
				return "", errors.New("empty xml string")
			}
		} else if t == "application/pgp-signature" {
			pgpSig := partData
			_, mediaTypeParams, err := m.Header.ContentType()
			if err != nil {
				err := errors.Wrap(err, "Error while getting content type")
				return "", err
			}
			boundary := mediaTypeParams["boundary"]
			verification, err := verifyPgpSignature(content, boundary, pgpSig)
			if err != nil {
				cve.Verified = "0"
				log.Info().
					Msg("PGP Verification failed")

				//				err :=  errors.Wrap(err, "Error during PGP Verification")
				//				return "", err
			} else if verification == true {
				cve.Verified = "1"
				log.Info().
					Msg("PGP Verification successful")
			} else {
				cve.Verified = "0"
				log.Info().
					Msg("PGP Verification failed")
			}
		} else {
			return "", errors.New("not supported content type" + t)
		}
	}
	return xmlData, nil
}

func processMessageInfo(client *pop3.Client, mis []pop3.MessageInfo, db *sqlx.DB) error {
	for _, mi := range mis {
		log.Info().
			Str("UID", mi.Uid).
			Int("Number", mi.Number).
			Msg("Processing message")

		content, err := client.Retr(mi.Number)
		if err != nil {
			err := errors.Wrap(err, "Error during POP3-Retr Command")
			return err
		}
		log.Debug().
			Str("UID", mi.Uid).
			Int("Number", mi.Number).
			Str("Content", content).
			Msg("Fetched content")

		r := strings.NewReader(content)
		m, err := message.Read(r)
		if err != nil {
			if message.IsUnknownCharset(err) {
				log.Error().
					Str("UID", mi.Uid).
					Int("Number", mi.Number).
					AnErr("Error", err).
					Msg("Unknown charset")
			} else {
				log.Error().
					Str("UID", mi.Uid).
					Int("Number", mi.Number).
					AnErr("Error", err).
					Msg("Failed to read message")
			}
			continue
		}

		cve, err := createCVECase(m)
		if err != nil {
			log.Error().
				Str("UID", mi.Uid).
				Int("Number", mi.Number).
				AnErr("Error", err).
				Msg("Could not create CVECase")
			err = client.Dele(mi.Number)
			if err != nil {
				err := errors.Wrap(err, "Error during POP3-Dele Command")
				return err
			}
			continue
		}
		cve.Source = "CERT"
		cve.RawData = content

		xmlData, err := getMultipartInfo(m, content, &cve)
		if err != nil {
			log.Error().
				Str("UID", mi.Uid).
				Int("Number", mi.Number).
				AnErr("Error", err).
				Msg("Can not get Multipart Info")
			err = client.Dele(mi.Number)
			if err != nil {
				err := errors.Wrap(err, "Error during POP3-Dele Command")
				return err
			}
			continue
		}
		//cve.Dump()

		if processXmlData(xmlData, &cve) {
			continue
		}

		if db != nil {
			err = cve.WriteToDB(db)
			if err != nil {
				log.Error().
					AnErr("Error", err)
			}
		}

		if !viper.GetBool("dry-run") && !viper.GetBool("no-dele") {
			err = client.Dele(mi.Number)
			if err != nil {
				err := errors.Wrap(err, "Error during POP3-Dele Command")
				return err
			}
		}
	}
	log.Info().Msg("Scanned all mails")
	return nil
}

func unique(intSlice []string) []string {
	keys := make(map[string]bool)
	var list []string
	for _, entry := range intSlice {
		if _, value := keys[entry]; !value {
			keys[entry] = true
			list = append(list, entry)
		}
	}
	return list
}

func processXmlData(xmlData string, cve *alertmanager.CveCase) bool {
	var cveAdvisory alertmanager.CveAdvisory
	//fmt.Println(xmlData)
	err := xml.Unmarshal([]byte(xmlData), &cveAdvisory)
	if err != nil {
		log.Error().
			AnErr("Error", err).
			Msg("Could not Unmarshal xml Data")
		return true
	}
	cve.Risk = "3"
	switch cveAdvisory.Risk {
	case "very_high":
		cve.Risk = "5"
	case "high":
		cve.Risk = "4"
	case "medium":
		cve.Risk = "3"
	case "low":
		cve.Risk = "2"
	case "very_low":
		cve.Risk = "1"
	default:
		log.Error().
			Msg("Unknown cveAdvisory.Risk: " + cveAdvisory.Risk)
	}
	cve.RefNum = cveAdvisory.RefNum
	regex := regexp.MustCompile(" Update(.*)")
	cve.OriginalRefNum = regex.ReplaceAllString(cve.RefNum, "")
	cve.CategoryList = unique(cveAdvisory.CategoryList)
	cve.CveNumList = cveAdvisory.CveList.CveNum
	cve.PlatformList = strings.Split(cveAdvisory.Platform, ", ")
	cve.SoftwareList = strings.Split(cveAdvisory.Software, ", ")

	regex = regexp.MustCompile("</TextBlock>\r\n</Element>\r\n<Element>\r\n<TextBlock>(.+)</TextBlock>\r\n</Element>\r\n<Element>")
	description := regex.FindString(xmlData)
	regex = regexp.MustCompile("(</TextBlock>\r\n</Element>\r\n<Element>\r\n<TextBlock>)|(</TextBlock>\r\n</Element>\r\n<Element>)")
	description = regex.ReplaceAllString(description, "")
	cve.Description = description

	return false
}

func verifyPgpSignature(content string, boundary string, signature string) (bool, error) {
	TestPublicKey := viper.GetString("certBundPublicKey")
	//fmt.Println(TestPublicKey)
	publicKeyEntity, err := pgp.GetEntity([]byte(TestPublicKey), []byte{})
	if err != nil {
		return false, errors.New("Error while creating publicKeyEntity")
	}

	log.Debug().
		Msg("Created public key entity")

	message := content

	regexString := `(?sm)[^\"]` + regexp.QuoteMeta("--"+boundary) + `\r?\n(.*?)` + regexp.QuoteMeta("--"+boundary)
	regex := regexp.MustCompile(regexString)
	message = regex.FindString(message)

	regex = regexp.MustCompile(`\s*\r?\n?` + regexp.QuoteMeta("--"+boundary) + `\s*\r?\n?`)
	message = regex.ReplaceAllString(message, "")

	message = message + "\r\n"
	log.Debug().
		Str("Message", message).
		Str("Signature", signature).
		Msg("Message part extracted")

	err = pgp.Verify(publicKeyEntity, []byte(message), []byte(signature))
	if err != nil {
		log.Debug().
			AnErr("Error", err).
			Msg("Failed PGP verification")
		return false, err
	}
	log.Debug().
		Msg("Signature verified using public key entity.")
	return true, nil
}

func RebuildDatabase(db *sqlx.DB) error {
	var length int
	err := db.Get(&length, db.Rebind("SELECT COUNT(*) FROM case_rawdatas"))
	if err != nil {
		log.Error().
			AnErr("Error", err).
			Msg("Could not execute query")
		return err
	}
	var rawdatas []string
	for i := 1; i < length+1; i++ {
		var rawdata string
		err = db.Get(&rawdata, db.Rebind("SELECT rawdata FROM case_rawdatas WHERE id = ?"), i)
		if err != nil {
			log.Error().
				AnErr("Error", err).
				Msg("Could not get rawdata of case " + strconv.Itoa(i))
		} else {
			rawdatas = append(rawdatas, rawdata)
		}
	}
	err = alertmanager.InitDB(db)
	if err != nil {
		log.Error().
			AnErr("Error", err).
			Msg("Could not initialize database")
		return err
	}
	for i, rawdata := range rawdatas {
		log.Info().Msg("Processing rawdata of case " + strconv.Itoa(i))
		r := strings.NewReader(rawdata)
		m, err := message.Read(r)
		if err != nil {
			if message.IsUnknownCharset(err) {
				log.Error().
					AnErr("Error", err).
					Msg("Unknown charset")
			} else {
				log.Error().
					AnErr("Error", err).
					Msg("Failed to read message")
			}
			continue
		}

		cve, err := createCVECase(m)
		if err != nil {
			log.Error().
				AnErr("Error", err).
				Msg("Could not create CVECase")
			continue
		}

		cve.Source = "CERT"
		cve.RawData = rawdata

		xmlData, err := getMultipartInfo(m, rawdata, &cve)
		if err != nil {
			log.Error().
				AnErr("Error", err).
				Msg("Can not get Multipart Info")
			continue
		}

		if processXmlData(xmlData, &cve) {
			continue
		}

		if db != nil {
			err = cve.WriteToDB(db)
			if err != nil {
				log.Error().
					AnErr("Error", err)
			}
		}
	}
	return nil
}

// FetchCertBund fetches all mails from CERT Bund.
func FetchCertBund(db *sqlx.DB) {
	if viper.GetString("certBundPop3.Host") == "" {
		log.Error().
			Msg("config variable certBundPop3.Host is not set")
		return
	}
	if viper.GetString("certBundPop3.Username") == "" {
		log.Error().
			Msg("config variable certBundPop3.Username is not set")
		return
	}
	if viper.GetString("certBundPop3.Password") == "" {
		log.Error().
			Msg("config variable certBundPop3.Password is not set")
		return
	}
	client, err := newPop3Client(viper.GetString("certBundPop3.Host"), viper.GetString("certBundPop3.Username"), viper.GetString("certBundPop3.Password"))
	if err != nil {
		log.Error().
			AnErr("Error", err).
			Msg("Could not connect to POP3 Client")
		return
	}
	defer func() {
		err = closePop3Client(client)
		if err != nil {
			log.Error().
				AnErr("Error", err).
				Msg("Could not disconnect POP3 Client")
		}
	}()

	messageInfo, err := getMessageInfo(client)
	if err != nil {
		log.Error().
			AnErr("Error", err).
			Msg("Could not get message info")
		return
	}

	err = processMessageInfo(client, messageInfo, db)
	if err != nil {
		log.Error().
			AnErr("Error", err).
			Msg("Could not process message info")
		return
	}

	if viper.GetBool("daemon") {
		log.Info().Msg("Running in Daemon mode, sleeping 30 min...")
		time.Sleep(30 * time.Minute)
		FetchCertBund(db)
	}
}

// FetchNist fetches all mails from Nist.
func FetchNist() { //currently not supported
	log.Error().
		Msg("Nist is currently not supported")
}
